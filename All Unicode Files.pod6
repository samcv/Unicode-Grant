=begin pod
=head2 B<List of Canonical Aliases>

=item PropertyAliases.txt
=item PropertyValueAliases.txt
=item NameAliases.txt

=head2 something else

=item ArabicShaping.txt
    =item2 I<This file defines the Joining_Type and Joining_Group property
    values for Arabic, Syriac, N'Ko, Mandaic, and Manichaean positional
    shaping, repeating in machine readable form the information
    exemplified in Tables 9-3, 9-8, 9-9, 9-10, 9-14, 9-15, 9-16, 9-19,
    9-20, 10-4, 10-5, 10-6, 10-7, and 19-5 of The Unicode Standard core
    specification. This file also defines Joining_Type values for
    Mongolian, Phags-pa, and Psalter Pahlavi positional shaping, which
    are not listed in tables in the standard.>


=item auxiliary/
    =item2 GraphemeBreakProperty.txt
        =item3 Important test for checking how Graphemes breakup
        =item3 [X] check breaking them up arbitrarily. I.E. instead of just
        checking on the total numbers, check when you .substr them
    =item2 GraphemeBreakTest.html
    =item2 GraphemeBreakTest.txt
    =item2 LineBreakTest.html
    =item2 LineBreakTest.txt
    =item2 SentenceBreakProperty.txt
    =item2 SentenceBreakTest.html
    =item2 SentenceBreakTest.txt
        =item3 UniProp_TEST: `Sentence_Break`
        =item3 Perl6-STATUS: N/A

    =item2 WordBreakProperty.txt
        =item3 UniProp_DATA: `Word_Break`
    =item2 WordBreakTest.html
    =item2 WordBreakTest.txt

=head1 Mirroring
=item BidiMirroring.txt
    =item2 UniProp: `Bidi_Paired_Bracket` `Bidi_Mirroring_Glyph`
    =item2 Glyphs which should be mirrored and their mirrored counterparts (when switching from LTR or RTL text)
    =item2 Also includes a list of codepoints which have no mirrored pair, but should be mirrored (by flipping).

=item BidiBrackets.txt #Data
    =item2 UniProp: `Bidi_Paired_Bracket_Type`
    =item2 Subset of BidiMirroringGlyph. And only includes brackets.
    =item2 **Note** does not include matched quotation marks.

=item BidiCharacterTest.txt #N/A
    =item2 *This file provides a conformance test for implementations of the Unicode Bidirectional Algorithm, specified in UAX \#9: Unicode.
    Bidirectional Algorithm, at http://www.unicode.org/reports/tr9/*
    =item2 Focuses on reordering of text from a single line

=item BidiTest.txt #N/A
    =item2 Tests conformance to Unicode BA focusing on more than a single line

=item Blocks.txt
    =item2 Data: Block
=item CaseFolding.txt
    =item2 This file is a supplement to the UnicodeData file.
        It provides a case folding mapping generated from the Unicode Character Database.
        If all characters are mapped according to the full mapping below, then
        case differences (according to UnicodeData.txt and SpecialCasing.txt)
        are eliminated.
=item CJKRadicals.txt
=item CompositionExclusions.txt
=item DerivedAge.txt
=item DerivedCoreProperties.txt
=item DerivedNormalizationProps.txt
=item EastAsianWidth.txt
=item EmojiSources.txt
    =item2 Shift-JIS Encoding
    =item2 This file provides mappings between Unicode code points and sequences on one hand
        and Shift-JIS codes for cell phone carrier symbols on the other hand.

=item extracted
    =item2 DerivedBidiClass.txt
    =item2 DerivedBinaryProperties.txt
    =item2 DerivedCombiningClass.txt
    =item2 DerivedDecompositionType.txt
    =item2 DerivedEastAsianWidth.txt
    =item2 DerivedGeneralCategory.txt
    =item2 DerivedJoiningGroup.txt
    =item2 DerivedJoiningType.txt
    =item2 DerivedLineBreak.txt
    =item2 DerivedNumericType.txt
    =item2 DerivedNumericValues.txt

=item HangulSyllableType.txt
=item Index.txt
=item IndicPositionalCategory.txt
=item IndicSyllabicCategory.txt
=item Jamo.txt
    =item2 Data: Jamo_Short_Name

=item LineBreak.txt
    =item2 Data: Line_Break

=item NamedSequencesProv.txt
=item NamedSequences.txt
=item NamesList.html
=item NamesList.txt
=item NormalizationCorrections.txt
=item NormalizationTest.txt
=item PropList.txt
    =item2 Uniprop_DATA
        =item3 White_Space
        =item3 Bidi_Control
        =item3 Join_Control
        =item3 Dash
        =item3 Hyphen
        =item3 Quotation_Mark
        =item3 Terminal_Punctuation
        =item3 Other_Math
        =item3 Hex_Digit
        =item3 ASCII_Hex_Digit
        =item3 Other_Alphabetic
        =item3 Ideographic
        =item3 Diacritic
        =item3 Extender
        =item3 Other_Lowercase
        =item3 Other_Uppercase
        =item3 Noncharacter_Code_Point
        =item3 Other_Grapheme_Extend
        =item3 IDS_Binary_Operator
        =item3 IDS_Trinary_Operator
        =item3 Radical
        =item3 Unified_Ideograph
        =item3 Other_Default_Ignorable_Code_Point
        =item3 Deprecated
        =item3 Soft_Dotted
        =item3 Logical_Order_Exception
        =item3 Other_ID_Start
        =item3 Other_ID_Continue

=item ReadMe.txt
=item ScriptExtensions.txt
=item Scripts.txt
=item SpecialCasing.txt
=item StandardizedVariants.html
=item StandardizedVariants.txt
=item TangutSources.txt
=item UCD.zip
=item UnicodeData.txt
=item Unihan.zip
=item USourceData.txt
=item USourceGlyphs.pdf
=end pod
use Terminal::ANSIColor;
sub traverse-pod ($thepod, $depth?, $type?) {
    given $thepod {
        when Array {
            for $thepod.list -> $a {
                traverse-pod($a, $depth, $type);
            }
        }
        #when FormattingCode
        when Pod::Block {
            if .isa(Pod::Block::Named) {
                my $n = $thepod.name;
                if $n eq 'done' {
                    print '- [X] ';
                }
                elsif $n eq 'todo' {
                    print '- [ ] ';
                }
                #   die $n;
            }
            my ($d, $t);
            try { $d = .level }
            try { $t = .type  }
            $d //= $depth;
            $t //= $type;
            traverse-pod .contents, $d, $t;
        }
        when Str {
            my $str = $depth.defined ?? " " x ($depth√ó2) !! "";
            $str ~= $_;
            if $type {
                my @styles;
                @styles.push('italic') if $type.contains('I');
                @styles.push('bold') if $type.contains('B');
                @styles.push('underline') if $type.contains('U');
                $str = colored($str, @styles.join(' ') );
            }
            $str.say;
        }
        default { die "oh no: ", .WHAT.VAR.gist };
    }

}
#say $=pod;

#exit;
#traverse-pod($=pod);
